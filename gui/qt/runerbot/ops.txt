;OPCODE					MNEMONIC		BYTES		CYCLES					FLAGS		DESCRIPTION


;PRIMARY INSTRUCTIONS

00000000				nop			1		1F					--------	No operation is performed.
00001000				ex af,af'		1		1F					--------	Exchanges the contents of .reg24af[3;1] and .reg24sh[3;1].
00010000........			djnz ofs8		2		b-1 ? 3F+1 : 2F				--------	.reg8[0;1] is decremented, and if not zero, the signed value .imm8[] is added to .regpc[]. The jump is measured from the start of the instruction opcode.
00011000........			jr ofs8			2		3F					--------	The signed value .ofs8[] is added to .regpc[]. The jump is measured from the start of the instruction opcode.
001..000........			jr cc,ofs8		2		cc ? 3F+1 : 2F				--------	If condition .cc[] is true, the signed value .ofs8[] is added to .regpc[]. The jump is measured from the start of the instruction opcode.

00..0001................		ld reg24,imm24		4		(3+.il)F				--------	Loads .imm24[] into .reg24[].
00..1001				add hl,reg24		1		1F					---H--NC	The value of .reg24[] is added to .reg24[2;1].

00000010				ld (bc),a		1		1F+1W					--------	Stores .reg8[7;1] into the byte of memory pointed to by .reg24[0;1].
00010010				ld (de),a		1		1F+1W					--------	Stores .reg8[7;1] into the byte of memory pointed to by .reg24[1;1].
00100010................		ld (imm24),hl		4		(3+.il)F+(2+.l)W			--------	Stores .reg24[2;1] into the word of memory pointed to by .imm24[].
00110010................		ld (imm24),a		4		(3+.il)F+1W				--------	Stores .reg8[7;1] into the byte of memory pointed to by .imm24[].
00001010				ld a,(bc)		1		1F+1R					--------	Loads the byte of memory pointed to by .reg24[0;1] into .reg8[7;1].
00011010				ld a,(de)		1		1F+1R					--------	Loads the byte of memory pointed to by .reg24[1;1] into .reg8[7;1].
00101010................		ld hl,(imm24)		4		(3+.il)F+(2+.l)R			--------	Loads the word of memory pointed to by .imm24[] into .reg24[2;1].
00111010................		ld a,(imm24)		4		(3+.il)F+1R				--------	Loads the byte of memory pointed to by .imm24[] into .reg8[7;1].

00..0011				inc reg24		1		1F					--------	Adds one to .reg24[].
00..1011				dec reg24		1		1F					--------	Subtracts one from .reg24[].

00110100				inc (hl)		1		1F+1R+1W+1				SZ-H-VN-	Adds one to .reg8[6].
00...100				inc reg8		1		1F					SZ-H-VN-	Adds one to .reg8[].

00110101				dec (hl)		1		1F+1R+1W+1				SZ-H-VN-	Subtracts one from .reg8[6].
00...101				dec reg8		1		1F					SZ-H-VN-	Subtracts one from .reg8[].

00110110........			ld (hl),imm8		2		2F+1W					--------	Loads .imm8[] into .reg8[6].
00...110........			ld reg8,imm8		2		2F					--------	Loads .imm8[] into .reg8[].

00000111				rlca			1		1F					---0--0C	The contents of .reg8[7;1] are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.
00001111				rrca			1		1F					---0--0C	The contents of .reg8[7;1] are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.
00010111				rla			1		1F					---0--0C	The contents of .reg8[7;1] are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.
00011111				rra			1		1F					---0--0C	The contents of .reg8[7;1] are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.
00100111				daa			1		1F					SZ-*-P-*	Adjusts .reg8[7;1] for BCD addition and subtraction operations.
00101111				cpl			1		1F					---1--1-	The contents of .reg8[7;1] are inverted (one's complement).
00110111				scf			1		1F					---0--01	Sets the carry flag.
00111111				ccf			1		1F					---*--0*	Inverts the carry flag.

010.00.011...000			ret.s cc		2		cc ? 3F+(3+(*SPL&1))R+2 : 2F+1		--------	If condition .cc[] is true, a byte is popped from SPL. If the byte is 2, ADL mode is reset and the top stack entry of SPS is popped into .regpc[]. If the byte is 3, ADL mode is set and the top stack entry of SPS is popped into .regpc[].
010.10.111...000			ret.l cc		2		cc ? 3F+(3+(*SPL&1))R+2 : 2F+1		--------	If condition .cc[] is true, a byte is popped from SPL. If the byte is 2, ADL mode is reset and the top stack entry of SPS is popped into .regpc[]. If the byte is 3, ADL mode is set and the top stack entry of SPS is popped into .regpc[].

010.00.011001001			ret.s			2		3F+(3+(*SPL&1))R+1			--------	A byte is popped from SPL. If the byte is 2, ADL mode is reset and the top stack entry of SPS is popped into .regpc[]. If the byte is 3, ADL mode is set and the top stack entry of SPS is popped into .regpc[].
010.10.111001001			ret.l			2		3F+(3+(*SPL&1))R+1			--------	A byte is popped from SPL. If the byte is 2, ADL mode is reset and the top stack entry of SPS is popped into .regpc[]. If the byte is 3, ADL mode is set and the top stack entry of SPS is popped into .regpc[].

010.00.01110110101000101		retn.s			3		4F+(3+(*SPL&1))R+1			--------	Used at the end of a non-maskable interrupt service routine. The top stack entry is popped into .regpc[]. The value of .iff2[] is copied to .iff1[] so that maskable interrupts are allowed to continue as before.
010.10.11110110101000101		retn.l			3		4F+(3+(*SPL&1))R+1			--------	Used at the end of a non-maskable interrupt service routine. The top stack entry is popped into .regpc[]. The value of .iff2[] is copied to .iff1[] so that maskable interrupts are allowed to continue as before.
010.00.01110110101001101		reti.s			3		4F+(3+(*SPL&1))R+1			--------	Used at the end of a maskable interrupt service routine. The top stack entry is popped into .regpc[]. The value of .iff2[] is copied to .iff1[] so that maskable interrupts are allowed to continue as before.
010.10.11110110101001101		reti.l			3		4F+(3+(*SPL&1))R+1			--------	Used at the end of a maskable interrupt service routine. The top stack entry is popped into .regpc[]. The value of .iff2[] is copied to .iff1[] so that maskable interrupts are allowed to continue as before.

010.00.011101001			jp.s (hl)		2		4F					--------	ADL mode is reset and loads the value of .reg16[2;1] into .regpc[].
010.10.111101001			jp.l (hl)		2		4F					--------	ADL mode is set and loads the value of .reg24[2;1] into .regpc[].

010.00.01101110111101001		jp.s (ix)		3		5F					--------	ADL mode is reset and loads the value of .regi[] into .regpc[].
010.10.11101110111101001		jp.l (ix)		3		5F					--------	ADL mode is set and loads the value of .regi[] into .regpc[].

010.00.01101111111101001		jp.s (iy)		3		5F					--------	ADL mode is reset and loads the value of .regi[] into .regpc[].
010.10.11101111111101001		jp.l (iy)		3		5F					--------	ADL mode is set and loads the value of .regi[] into .regpc[].

0100000011...010................	jp.sis cc,imm16		4		cc ? 3F+1 : 3F				--------	If condition .cc[] is true, ADL mode is reset and .imm16[] is copied to .regpc[].
0100100111...010................	jp.lis cc,imm16		4		cc ? 3F+1 : 3F				--------	If condition .cc[] is true, ADL mode is set and .imm16[] is copied to .regpc[].
0101001011...010................	jp.sil cc,imm24		5		cc ? 4F+1 : 4F				--------	If condition .cc[] is true, ADL mode is reset and .imm24[]&.imm16[h;FFFF;1] is copied to .regpc[].
0101101111...010................	jp.lil cc,imm24		5		cc ? 4F+1 : 4F				--------	If condition .cc[] is true, ADL mode is set and .imm24[] is copied to .regpc[].

0100000011000011................	jp.sis imm16		4		3F+1					--------	ADL mode is reset and .imm16[] is copied to .regpc[].
0100100111000011................	jp.lis imm16		4		3F+1					--------	ADL mode is reset and .imm16[] is copied to .regpc[].
0101001011000011................	jp.sil imm24		5		4F+1					--------	ADL mode is set and .imm24[]&.imm16[h;FFFF;1] is copied to .regpc[].
0101101111000011................	jp.lil imm24		5		4F+1					--------	ADL mode is set and .imm24[] is copied to .regpc[].

0100000011...100................	call.sis cc,imm16	4		cc ? 4F+3W : 4F				--------	If condition .cc[] is true, the .regpc[] value after this instruction is pushed onto the SPS stack, the byte 2 is pushed onto the SPL stack, ADL mode is reset, and then .regpc[] is loaded with .imm16[].
0100100111...100................	call.lis cc,imm16	4		cc ? 4F+4W ; 4F				--------	If condition .cc[] is true, the .regpc[] value after this instruction is pushed onto the SPS stack, the upper byte of .regpc[] value after this instruction is pushed onto the SPL stack, the byte 3 is pushed onto the SPL stack, ADL mode is reset, and then .regpc[] is loaded with .imm16[].
0101001011...100................	call.sil cc,imm24	5		cc ? 5F+3W : 5F				--------	If condition .cc[] is true, the .regpc[] value after this instruction is pushed onto the SPL stack, the byte 2 is pushed onto the SPL stack, ADL mode is set, and then .regpc[] is loaded with .imm24[].
0101101111...100................	call.lil cc,imm24	5		cc ? 5F+4W : 5F				--------	If condition .cc[] is true, the .regpc[] value after this instruction is pushed onto the SPL stack, the byte 3 is pushed onto the SPL stack, ADL mode is set, and then .regpc[] is loaded with .imm24[].

0100000011001101................	call.sis imm16		4		4F+3W					--------	The .regpc[] value after this instruction is pushed onto the SPS stack, the byte 2 is pushed onto the SPL stack, ADL mode is reset, and then .regpc[] is loaded with .imm16[].
0100100111001101................	call.lis imm16		4		4F+4W					--------	The .regpc[] value after this instruction is pushed onto the SPS stack, the upper byte of .regpc[] value after this instruction is pushed onto the SPL stack, the byte 3 is pushed onto the SPL stack, ADL mode is reset, and then .regpc[] is loaded with .imm16[].
0101001011001101................	call.sil imm24		5		5F+3W					--------	The .regpc[] value after this instruction is pushed onto the SPL stack, the byte 2 is pushed onto the SPL stack, ADL mode is set, and then .regpc[] is loaded with .imm24[].
0101101111001101................	call.lil imm24		5		5F+4W					--------	The .regpc[] value after this instruction is pushed onto the SPL stack, the byte 3 is pushed onto the SPL stack, ADL mode is set, and then .regpc[] is loaded with .imm24[].

0100000011...111................	rst.sis imm8		2		3F+3W+1					--------	The .regpc[] value after this instruction is pushed onto the SPS stack, the byte 2 is pushed onto the SPL stack, ADL mode is reset, and then .regpc[] is loaded with .dec2h[].
0100100111...111................	rst.lis imm8		2		3F+4W+1					--------	The .regpc[] value after this instruction is pushed onto the SPS stack, the upper byte of .regpc[] value after this instruction is pushed onto the SPL stack, the byte 3 is pushed onto the SPL stack, ADL mode is reset, and then .regpc[] is loaded with .dec2h[].
0101001011...111................	rst.sil imm8		2		3F+3W+1					--------	The .regpc[] value after this instruction is pushed onto the SPL stack, the byte 2 is pushed onto the SPL stack, ADL mode is set, and then .regpc[] is loaded with .dec2h[].
0101101111...111................	rst.lil imm8		2		3F+4W+1					--------	The .regpc[] value after this instruction is pushed onto the SPL stack, the byte 3 is pushed onto the SPL stack, ADL mode is set, and then .regpc[] is loaded with .dec2h[].

01110110				halt			1		1F					--------	Suspends CPU operation until an interrupt or reset occurs.

01000110				ld b,(hl)		1		1F+1R					--------	The contents of .reg8[6] are loaded into .reg8[].
01001110				ld c,(hl)		1		1F+1R					--------	The contents of .reg8[6] are loaded into .reg8[].
01010110				ld d,(hl)		1		1F+1R					--------	The contents of .reg8[6] are loaded into .reg8[].
01011110				ld e,(hl)		1		1F+1R					--------	The contents of .reg8[6] are loaded into .reg8[].
01100110				ld h,(hl)		1		1F+1R					--------	The contents of .reg8[6] are loaded into .reg8[].
01101110				ld l,(hl)		1		1F+1R					--------	The contents of .reg8[6] are loaded into .reg8[].
01111110				ld a,(hl)		1		1F+1R					--------	The contents of .reg8[6] are loaded into .reg8[].

01110000				ld (hl),b		1		1F+1W					--------	The contents of .reg8[] are loaded into .reg8[6].
01110001				ld (hl),c		1		1F+1W					--------	The contents of .reg8[] are loaded into .reg8[6].
01110010				ld (hl),d		1		1F+1W					--------	The contents of .reg8[] are loaded into .reg8[6].
01110011				ld (hl),e		1		1F+1W					--------	The contents of .reg8[] are loaded into .reg8[6].
01110100				ld (hl),h		1		1F+1W					--------	The contents of .reg8[] are loaded into .reg8[6].
01110101				ld (hl),l		1		1F+1W					--------	The contents of .reg8[] are loaded into .reg8[6].
01110111				ld (hl),a		1		1F+1W					--------	The contents of .reg8[] are loaded into .reg8[6].

01......				ld reg8,reg8		1		1F					--------	The contents of the second register .reg8[] are loaded into the first register .reg8[].

10000110				add a,(hl)		1		1F+1R					SZ-H-VNC	Adds .reg8[6] to .reg8[7;1].
10000...				add a,reg8		1		1F					SZ-H-VNC	Adds .reg8[] to .reg8[7;1].
10001110				adc a,(hl)		1		1F+1R					SZ-H-VNC	Adds .reg8[6] and the carry flag to .reg8[7;1].
10001...				adc a,reg8		1		1F					SZ-H-VNC	Adds .reg8[] and the carry flag to .reg8[7;1].
10010110				sub a,(hl)		1		1F+1R					SZ-H-VNC	Subtracts .reg8[6] from .reg8[7;1].
10010...				sub a,reg8		1		1F					SZ-H-VNC	Subtracts .reg8[] from .reg8[7;1].
10011110				sbc a,(hl)		1		1F+1R					SZ-H-VNC	Subtracts .reg8[6] and the carry flag from .reg8[7;1].	
10011...				sbc a,reg8		1		1F					SZ-H-VNC	Subtracts .reg8[] and the carry flag from .reg8[7;1].	
10100110				and a,(hl)		1		1F+1R					SZ-1-P00	Bitwise AND on .reg8[7;1] with .reg8[6].
10100...				and a,reg8		1		1F					SZ-1-P00	Bitwise AND on .reg8[7;1] with .reg8[].
10101110				xor a,(hl)		1		1F+1R					SZ-0-P00	Bitwise XOR on .reg8[7;1] with .reg8[6].
10101...				xor a,reg8		1		1F					SZ-0-P00	Bitwise XOR on .reg8[7;1] with .reg8[].
10110110				or a,(hl)		1		1F+1R					SZ-0-P00	Bitwise OR on .reg8[7;1] with .reg8[6].
10110...				or a,reg8		1		1F					SZ-0-P00	Bitwise OR on .reg8[7;1] with .reg8[].
10111110				cp a,(hl)		1		1F+1R					SZ-H-VNC	Subtracts .reg8[6] from .reg8[7;1] and affects flags according to the result. .reg8[7;1] is not modified.
10111...				cp a,reg8		1		1F					SZ-H-VNC	Subtracts .reg8[] from .reg8[7;1] and affects flags according to the result. .reg8[7;1] is not modified.

11...000				ret cc			1		cc ? 2F+(2+.l)R+2 : 1F+1		--------	If condition .cc[] is true, the top stack entry is popped into .regpc[].

11..0001				pop reg24		1		1F+(2+.l)R				--------	The word of memory pointed to by .reg24[3;1] is stored into .reg24[] and .reg24[3;1] is incremented by the word size.
11001001				ret			1		2F+(2+.l)R+1				--------	The top stack entry is popped into .regpc[].
11011001				exx			1		1F					--------	Exchanges the contents of .reg24af[0;1], .reg24af[1;1], and .reg24af[2;1] with .reg24sh[0;1], .reg24sh[1;1], and .reg24sh[2;1].
11101001				jp (hl)			1		3F					--------	Loads the value of .reg24[2;1] into .regpc[].
11111001				ld sp,hl		1		1F					--------	Loads the value of .reg24[2;1] into .reg24[3;1].

11...010................		jp cc,imm24		4		cc ? (3+.il)F+1 : (3+.il)F		--------	If condition .cc[] is true, .imm24[] is copied to .regpc[].

11000011................		jp imm24		4		(3+.il)F+1				--------	.imm24[] is copied to .regpc[].
;11001011				BIT INSTRUCTIONS
11010011........			out (imm8),a		2		2F+1W					--------	Writes .reg8[7;1] to port {.reg8[7;1], .imm8[]}
11011011........			in a,(imm8)		2		2F+1R					--------	Reads a byte from port {.reg8[7;1], .imm8[]} to .reg8[7;1].
11100011				ex (sp),hl		1		1F+(2+.l)R+(2+.l)W			--------	Exchanges the word of memory pointed to by .reg24[3;1] with .reg24[2;1].
11101011				ex de,hl		1		1F					--------	Exchanges the contents of .reg24[1;1] and .reg24[2;1].
11110011				di			1		1F					--------	Resets both interrupt flip-flops, thus preventing maskable interrupts from triggering.
11111011				ei			1		1F					--------	Sets both interrupt flip-flops, thus allowing maskable interrupts to occur. An interrupt will not occur until after the immediatedly following instruction.

11...100................		call cc,imm24		4		cc ? (3+.il)F+3W : (3+.il)F		--------	If condition .cc[] is true, the .regpc[] value after this instruction is pushed onto the stack, then is loaded with .imm24[].

11..0101				push reg24		1		1F+(2+.l)W				--------	.reg24[3;1] is decremented by the word size and .reg24[] is stored into the word of memory pointed to by .reg24[3;1].
11001101................		call imm24		4		(3+.il)F+(2+.il)W			--------	The .regpc[] value after this instruction is pushed onto the stack, then is loaded with .imm24[].
;11011101				IX PRIMARY INSTRUCTIONS
;11101101				EXTENDED INSTRUCTIONS
;11111101				IY PRIMARY INSTRUCTIONS

11000110........			add a,imm8		2		2F					SZ-H-VNC	Adds .imm8[] to .reg8[7;1].
11001110........			adc a,imm8		2		2F					SZ-H-VNC	Adds .imm8[] and the carry flag to .reg8[7;1].
11010110........			sub a,imm8		2		2F					SZ-H-VNC	Subtracts .imm8[] from .reg8[7;1].
11011110........			sbc a,imm8		2		2F					SZ-H-VNC	Subtracts .imm8[] and the carry flag from .reg8[7;1].
11100110........			and a,imm8		2		2F					SZ-1-P00	Bitwise AND on .reg8[7;1] with .imm8[].
11101110........			xor a,imm8		2		2F					SZ-0-P00	Bitwise XOR on .reg8[7;1] with .imm8[].
11110110........			or a,imm8		2		2F					SZ-0-P00	Bitwise OR on .reg8[7;1] with .imm8[].
11111110........			cp a,imm8		2		2F					SZ-H-VNC	Subtracts .imm8[] from .reg8[7;1] and affects flags according to the result. .reg8[7;1] is not modified.

11...111				rst imm8		1		2F+(2+.l)W+1				--------	The .regpc[] value after this instruction is pushed onto the stack, then is loaded with .dec2h[].


;BIT INSTRUCTIONS

1100101100000110			rlc (hl)		2		2F+1R+1W+1				SZ-0-P0C	The contents of .reg8[6] are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.
1100101100000...			rlc reg8		2		2F					SZ-0-P0C	The contents of .reg8[] are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.
1100101100001110			rrc (hl)		2		2F+1R+1W+1				SZ-0-P0C	The contents of .reg8[6] are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.
1100101100001...			rrc reg8		2		2F					SZ-0-P0C	The contents of .reg8[] are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.
1100101100010110			rl (hl)			2		2F+1R+1W+1				SZ-0-P0C	The contents of .reg8[6] are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.
1100101100010...			rl reg8			2		2F					SZ-0-P0C	The contents of .reg8[] are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.
1100101100011110			rr (hl)			2		2F+1R+1W+1				SZ-0-P0C	The contents of .reg8[6] are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.
1100101100011...			rr reg8			2		2F					SZ-0-P0C	The contents of .reg8[] are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.
1100101100100110			sla (hl)		2		2F+1R+1W+1				SZ-0-P0C	The contents of .reg8[6] are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.
1100101100100...			sla reg8		2		2F					SZ-0-P0C	The contents of .reg8[] are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.
1100101100101110			sra (hl)		2		2F+1R+1W+1				SZ-0-P0C	The contents of .reg8[6] are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.
1100101100101...			sra reg8		2		2F					SZ-0-P0C	The contents of .reg8[] are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.
1100101100110...			trap			2		2F					--------	It's a trap!
1100101100111110			srl (hl)		2		2F+1R+1W+1				SZ-0-P0C	The contents of .reg8[6] are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.
1100101100111...			srl reg8		2		2F					SZ-0-P0C	The contents of .reg8[] are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.

1100101101...110			bit imm3,(hl)		2		2F+1R					*Z-1-*0-	Tests bit .imm3[] of .reg8[6].
1100101101......			bit imm3,reg8		2		2F					*Z-1-*0-	Tests bit .imm3[] of .reg8[].

1100101110...110			res imm3,(hl)		2		2F+1R+1W+1				--------	Resets bit .imm3[] of .reg8[6].
1100101110......			res imm3,reg8		2		2F					--------	Resets bit .imm3[] of .reg8[].

1100101111...110			set imm3,(hl)		2		2F+1R+1W+1				--------	Sets bit .imm3[] of .reg8[6].
1100101111......			set imm3,reg8		2		2F					--------	Sets bit .imm3[] of .reg8[].


;EXTENDED INSTRUCTIONS

1110110100110000........		in0 (imm8)		3		3F+1R					SZ-0-P0-	Reads a byte from port .imm8[], affecting flags only.
1110110100...000........		in0 reg8,(imm8)		3		3F+1R					SZ-0-P0-	Reads a byte from port .imm8[] to .reg8[].

1110110100110001			ld iy,(hl)		2		2F+(2+.l)R				--------	Loads the word of memory pointed to by .reg24[2;1] into .regi[1].
1110110100...001........		out0 reg8,(imm8)	3		3F+1W					--------	Writes .reg8[] to port .imm8[].

1110110100110010........		lea ix,ix+ofs8		3		3F					--------	Stores .regi[0] plus .ofs8[] into .regi[0].
1110110100..0010........		lea reg24,ix+ofs8	3		3F					--------	Stores .regi[0] plus .ofs8[] into .reg24[].

1110110100110011........		lea iy,iy+ofs8		3		3F					--------	Stores .regi[1] plus .ofs8[] into .regi[1].
1110110100..0011........		lea reg24,iy+ofs8	3		3F					--------	Stores .regi[1] plus .ofs8[] into .reg24[].

1110110100110100			tst a,(hl)		2		2F+1R					SZ-1-P00	Bitwise AND on .reg8[7;1] with .reg8[6] and affects flags according to the result. .reg8[7;1] is not modified.
1110110100...100			tst a,reg8		2		2F					SZ-1-P00	Bitwise AND on .reg8[7;1] with .reg8[] and affects flags according to the result. .reg8[7;1] is not modified.

1110110100111110			ld (hl),iy		2		2F+(2+.l)W				--------	Stores .regi[1] into the word of memory pointed to by .reg24[2;1].

1110110100110111			ld ix,(hl)		2		2F+(2+.l)R				--------	Loads the word of memory pointed to by .reg24[2;1] into .regi[0].
1110110100..0111			ld reg24,(hl)		2		2F+(2+.l)R				--------	Loads the word of memory pointed to by .reg24[2;1] into .reg24[].
1110110100111111			ld (hl),ix		2		2F+(2+.l)W				--------	Stores .regi[0] into the word of memory pointed to by .reg24[2;1].
1110110100..1111			ld (hl),reg24		2		2F+(2+.l)W				--------	Stores .reg24[] into the word of memory pointed to by .reg24[2;1].

1110110101110000			in (bc)			2		2F+1R					SZ-0-P0-	Reads a byte from port .reg16[0;1], affecting flags only.
1110110101...000			in reg8,(bc)		2		2F+1R					SZ-0-P0-	Reads a byte from port .reg16[0;1] to .reg8[].

1110110101110001			trap			2		2F					--------	It's a trap!
1110110101...001			out (bc),reg8		2		2F+1W					--------	Writes .reg8[] to port .reg16[0;1].

1110110101..0010			sbc hl,reg24		2		2F					SZ-H-VNC	Subtracts .reg24[] and the carry flag from .reg24[2;1].
1110110101..1010			adc hl,reg24		2		2F					SZ-H-VNC	Adds .reg24[] and the carry flag to .reg24[2;1].

1110110101..0011................	ld (imm24),reg24	5		(4+.il)F+(2+.l)W			--------	Stores .reg24[] into the word of memory pointed to by .imm24[].
1110110101..1011................	ld reg24,(imm24)	5		(4+.il)F+(2+.l)R			--------	Loads the word of memory pointed to by .imm24[] into .reg24[].

1110110101000100			neg			2		2F					SZ-H-VNC	The contents of .reg8[7;1] are negated (two's complement). Operation is the same as subtracting .reg8[7;1] from zero.
1110110101..1100			mlt reg24		2		2F+4					--------	Multiplies the low bytes of .reg24[] together and stores the result back.
1110110101010100........		lea ix,iy+ofs8		3		3F					--------	Stores .regi[1] plus .ofs8[] into .regi[0].
1110110101100100........		tst a,imm8		3		3F					SZ-1-P00	Bitwise AND on .reg8[7;1] with .imm8[] and affects flags according to the result. .reg8[7;1] is not modified.
1110110101110100........		tstio imm8		3		3F+1R					SZ-1-P00	Bitwise AND on .imm8[] with a byte read from port .reg8[1;1] and affects flags according to the result.

1110110101000101			retn			2		3F+(2+.l)R+1				--------	Used at the end of a non-maskable interrupt service routine. The top stack entry is popped into .regpc[]. The value of .iff2[] is copied to .iff1[] so that maskable interrupts are allowed to continue as before.
1110110101001101			reti			2		3F+(2+.l)R+1				--------	Used at the end of a maskable interrupt service routine. The top stack entry is popped into .regpc[]. The value of .iff2[] is copied to .iff1[] so that maskable interrupts are allowed to continue as before.
1110110101010101........		lea iy,ix+ofs8		3		3F					--------	Stores .regi[0] plus .ofs8[] into .regi[1].
1110110101100101........		pea ix+ofs8		3		3F+(2+.l)W				--------	.reg24[3;1] is decremented by the word size and .regi[0] plus .ofs8[] is stored into the word of memory pointed to by .reg24[3;1].
1110110101101101			ld mb,a			2		2F					--------	Stores the value of .reg8[7;1] into .regmb[].
1110110101111101			stmix			2		2F					--------	Sets the mixed memory mode flag.

1110110101000110			im 0			2		2F					--------	Sets interrupt mode 0.
1110110101010110			im 1			2		2F					--------	Sets interrupt mode 1.
1110110101011110			im 2			2		2F					--------	Sets interrupt mode 2.
1110110101100110........		pea iy+ofs8		3		3F+(2+.l)W				--------	.reg24[3;1] is decremented by the word size and .regi[1] plus .ofs8[] is stored into the word of memory pointed to by .reg24[3;1].
1110110101101110			ld a,mb			2		2F					--------	Stores the value of .regmb[] into .reg8[7;1].
1110110101110110			slp			2		2F					--------	Suspends CPU operation until an interrupt or reset occurs.
1110110101111110			rsmix			2		2F					--------	Resets the mixed memory mode flag.

1110110101000111			ld i,a			2		2F					--------	Stores the value of .reg8[7;1] into .reg8ir[0;1].
1110110101001111			ld r,a			2		2F					--------	Stores the value of .reg8[7;1] into .reg8ir[1;1].
1110110101010111			ld a,i			2		2F					SZ-0-*0-	Stores the value of .reg8ir[0;1] into .reg8[7;1].
1110110101011111			ld a,r			2		2F					SZ-0-*0-	Stores the value of .reg8ir[1;1] into .reg8[7;1].
1110110101100111			rrd			2		2F+1R+1W+1				SZ-0-P0-	The contents of the low-nibble of .reg8[6;1] are copied to the low-order nibble of .reg8[7;1]. The previous contents are copied to the high-order nibble of .reg8[6;1]. The previous contents are copied to the low-order nibble of .reg8[6;1].
1110110101101111			rld			2		2F+1R+1W+1				SZ-0-P0-	The contents of the low-order nibble of .reg8[6;1] are copied to the high-order nibble of .reg8[6;1]. The previous contents are copied to the low-order nibble of .reg8[7;1]. The previous contents are copied to the low-order nibble of .reg8[6;1].

1110110110100000			ldi			2		2F+1R+1W+1				---0-*0-	Transfers the byte of memory pointed to by .reg24[2;1] to the memory location pointed to by .reg24[1;1]. Then .reg24[2;1] and .reg24[1;1] are incremented and .reg24[0;1] is decremented.
1110110110101000			ldd			2		2F+1R+1W+1				---0-*0-	Transfers the byte of memory pointed to by .reg24[2;1] to the memory location pointed to by .reg24[1;1]. Then .reg24[2;1], .reg24[1;1], and .reg24[0;1] are decremented.
1110110110110000			ldir			2		2F+(1R+1W+1)*bc				---0-*0-	Transfers the byte of memory pointed to by .reg24[2;1] to the memory location pointed to by .reg24[1;1]. Then .reg24[2;1] and .reg24[1;1] are incremented and .reg24[0;1] is decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.
1110110110111000			lddr			2		2F+(1R+1W+1)*bc				---0-*0-	Transfers the byte of memory pointed to by .reg24[2;1] to the memory location pointed to by .reg24[1;1]. Then .reg24[2;1], .reg24[1;1], and .reg24[0;1] are decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.

1110110110100001			cpi			2		2F+1R					SZ-H-*1-	Compares the byte of memory pointed to by .reg24[2;1] with .reg8[7;1]. Then .reg24[2;1] is incremented and .reg24[0;1] is decremented.
1110110110101001			cpd			2		2F+1R					SZ-H-*1-	Compares the byte of memory pointed to by .reg24[2;1] with .reg8[7;1]. Then .reg24[2;1] and .reg24[0;1] are decremented.
1110110110110001			cpir			2		2F+(1R+2)*bc-1				SZ-H-*1-	Compares the byte of memory pointed to by .reg24[2;1] with .reg8[7;1]. Then .reg24[2;1] is incremented and .reg24[0;1] is decremented. If .reg24[0;1] is not zero and .cc[1;1] is not set, this operation is repeated. Interrupts can trigger while this instruction is processing.
1110110110111001			cpdr			2		2F+(1R+2)*bc-1				SZ-H-*1-	Compares the byte of memory pointed to by .reg24[2;1] with .reg8[7;1]. Then .reg24[2;1] and .reg24[0;1] are decremented. If .reg24[0;1] is not zero and .cc[1;1] is not set, this operation is repeated. Interrupts can trigger while this instruction is processing.

1110110110000010			inim			2		2F+1R+1W+1				?*-?-?*?	A byte from port .reg8[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] and .reg8[1;1] are incremented and .reg8[0;1] is decremented.
1110110110001010			indm			2		2F+1R+1W+1				?*-?-?*?	A byte from port .reg8[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1], .reg8[0;1], and .reg8[1;1] are decremented.
1110110110010010			inimr			2		2F+(1R+1W+1)*b				-*----*-	A byte from port .reg8[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] and .reg8[1;1] are incremented .reg8[0;1] and is decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.
1110110110011010			indmr			2		2F+(1R+1W+1)*b				-*----*-	A byte from port .reg8[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1], .reg8[0;1], and .reg8[1;1] are decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.
1110110110100010			ini			2		2F+1R+1W+1				-*----*-	A byte from port .reg16[0;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] is incremented and .reg8[0;1] is decremented.
1110110110101010			ind			2		2F+1R+1W+1				-*----*-	A byte from port .reg16[0;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] and .reg8[0;1] are decremented.
1110110110110010			inir			2		2F+(1R+1W+1)*b				-*----*-	A byte from port .reg16[0;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] is incremented and .reg8[0;1] is decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.
1110110110111010			indr			2		2F+(1R+1W+1)*b				-*----*-	A byte from port .reg16[0;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] and .reg8[0;1] are decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.
1110110111000010			inirx			2		2F+(1R+1W+1)*bc				-*----*-	A byte from port .reg16[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] is incremented and .reg24[0;1] is decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.
1110110111001010			indrx			2		2F+(1R+1W+1)*bc				-*----*-	A byte from port .reg16[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] and .reg24[0;1] are decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.

1110110110000011			otim			2		2F+1R+1W+1				?*-?-?*?	The byte of memory pointed to by .reg24[2;1] is written to port .reg8[1;1]. Then .reg24[2;1] and .reg8[1;1] are incremented and .reg8[0;1] is decremented.
1110110110001011			otdm			2		2F+1R+1W+1				?*-?-?*?	The byte of memory pointed to by .reg24[2;1] is written to port .reg8[1;1]. Then .reg24[2;1], .reg8[0;1], and .reg8[1;1] are decremented.
1110110110010011			otimr			2		2F+(1R+1W+1)*b				?*-?-?*?	The byte of memory pointed to by .reg24[2;1] is written to port .reg8[1;1]. Then .reg24[2;1] and .reg8[1;1] are incremented .reg8[0;1] and is decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.
1110110110011011			otdmr			2		2F+(1R+1W+1)*b				?*-?-?*?	The byte of memory pointed to by .reg24[2;1] is written to port .reg8[1;1]. Then .reg24[2;1], .reg8[0;1], and .reg8[1;1] are decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.
1110110110100011			outi			2		2F+1R+1W+1				-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[0;1]. Then .reg24[2;1] is incremented and .reg8[0;1] is decremented.
1110110110101011			outd			2		2F+1R+1W+1				-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[0;1]. Then .reg24[2;1] and .reg8[0;1] are decremented.
1110110110110011			otir			2		2F+(1R+1W+1)*b				-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[0;1]. Then .reg24[2;1] is incremented and .reg8[0;1] is decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.
1110110110111011			otdr			2		2F+(1R+1W+1)*b				-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[0;1]. Then .reg24[2;1] and .reg8[0;1] are decremented. If .reg8[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.
1110110111000011			otirx			2		2F+(1R+1W+1)*bc				-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[1;1]. Then .reg24[2;1] is incremented and .reg24[0;1] is decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.
1110110111001011			otdrx			2		2F+(1R+1W+1)*bc				-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[1;1]. Then .reg24[2;1] and .reg24[0;1] are decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.

1110110110000100			ini2			2		2F+1R+1W+1				-*----*-	A byte from port .reg16[0;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] and .reg8[1;1] are incremented and .reg8[0;1] is decremented.
1110110110001100			ind2			2		2F+1R+1W+1				-*----*-	A byte from port .reg16[0;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1], .reg8[0;1], and .reg8[1;1] are decremented.
1110110110010100			ini2r			2		2F+(1R+1W+1)*bc				-*----*-	A byte from port .reg16[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1] and .reg16[1;1] are incremented and .reg24[0;1] is decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.
1110110110011100			ind2r			2		2F+(1R+1W+1)*bc				-*----*-	A byte from port .reg16[1;1] is written to the memory location pointed to by .reg24[2;1]. Then .reg24[2;1], .reg16[1;1], and .reg24[0;1] are decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.
1110110110100100			outi2			2		2F+1R+1W+1				-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[0;1]. Then .reg24[2;1] and .reg8[1;1] are incremented and .reg8[0;1] is decremented.
1110110110101100			outd2			2		2F+1R+1W+1				-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[0;1]. Then .reg24[2;1], .reg8[0;1], and .reg8[1;1] are decremented.
1110110110110100			oti2r			2		2F+(1R+1W+1)*bc				-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[1;1]. Then .reg24[2;1] and .reg16[1;1] are incremented and .reg24[0;1] is decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.
1110110110111100			otd2r			2		2F+(1R+1W+1)*bc				-*----*-	The byte of memory pointed to by .reg24[2;1] is written to port .reg16[1;1]. Then .reg24[2;1], .reg16[1;1], and .reg24[0;1] are decremented. If .reg24[0;1] is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.

1110110111000111			ld i,hl			2		2F					--------	Stores the value of .reg16[2;1] into .reg8ir[0;1].
1110110111010111			ld hl,i			2		2F					SZ-0-*0-	Stores the value of (.regmb[] << 16) + .reg8ir[0;1] into .reg24[2;1].

11101101........			trap			2		2F					--------	It's a trap!


;IX BIT INSTRUCTIONS

1101110111001011........00000110	rlc (ix+ofs8)		4		4F+1R+1W+1				SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.
1101110111001011........00001110	rrc (ix+ofs8)		4		4F+1R+1W+1				SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.
1101110111001011........00010110	rl (ix+ofs8)		4		4F+1R+1W+1				SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.
1101110111001011........00011110	rr (ix+ofs8)		4		4F+1R+1W+1				SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.
1101110111001011........00100110	sla (ix+ofs8)		4		4F+1R+1W+1				SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.
1101110111001011........00101110	sra (ix+ofs8)		4		4F+1R+1W+1				SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.
1101110111001011........00111110	srl (ix+ofs8)		4		4F+1R+1W+1				SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.

1101110111001011........01...110	bit imm3,(ix+ofs8)	4		4F+1R					?Z-1-?0-	Tests bit .imm3[] of the byte of memory pointed to by .regi[] plus .ofs8[].

1101110111001011........10...110	res imm3,(ix+ofs8)	4		4F+1R+1W+1				--------	Resets bit .imm3[] of the byte of memory pointed to by .regi[] plus .ofs8[].

1101110111001011........11...110	set imm3,(ix+ofs8)	4		4F+1R+1W+1				--------	Sets bit .imm3[] of the byte of memory pointed to by .regi[] plus .ofs8[].

1101110111001011................	trap			4		4F					--------	It's a trap!


;IX PRIMARY INSTRUCTIONS

1101110100..1001			add ix,reg24		2		2F					---H--NC	The value of .reg24[] is added to .regi[].
1101110100100001................	ld ix,imm24		5		(4+.il)F				--------	Loads .imm24[] into .regi[].
1101110100110001........		ld iy,(ix+ofs8)		3		3F+(2+.il)R				--------	Loads the word of memory pointed to by .regi[] plus .ofs8[] into .regiopp[].

1101110100100010................	ld (imm24),ix		5		(4+.il)F+(2+.l)W			--------	Stores .regi[] into the word of memory pointed to by .imm24[].
1101110100101010................	ld ix,(imm24)		5		(4+.il)F+(2+.l)R			--------	Loads the word of memory pointed to by .imm24[] into .regi[].

1101110100100011			inc ix			2		2F					--------	Adds one to .regi[].
1101110100101011			dec ix			2		2F					--------	Subtracts one from .regi[].

110111010010.100			inc reg8index		2		2F					SZ-H-VN-	Adds one to .regi8[].
1101110100110100........		inc (ix+ofs8)		3		3F+1R+1W+1				SZ-H-VN-	Adds one to the byte of memory pointed to by .regi[] plus .ofs8[].

110111010010.101			dec reg8index		2		2F					SZ-H-VN-	Subtracts one from .regi8[].
1101110100110101........		dec (ix+ofs8)		3		3F+1R+1W+1				SZ-H-VN-	Subtracts one from the byte of memory pointed to by .regi[] plus .ofs8[].

110111010010.110........		ld reg8index,imm8	3		3F					--------	Loads .imm8[] into .regi8[].
1101110100110110................	ld (ix+ofs8),imm8	4		4F+1W					--------	Stores .imm8[] to the byte of memory pointed to by .regi[] plus .ofs8[].
1101110100111110........		ld (ix+ofs8),iy		3		3F+(2+.l)W				--------	Stores .regiopp[] into the word of memory pointed to by .regi[] plus .ofs8[].

1101110100110111........		ld ix,(ix+ofs8)		3		3F+(2+.l)R				--------	Loads the word of memory pointed to by .regi[] plus .ofs8[] into .regi[].
1101110100..0111........		ld reg24,(ix+ofs8)	3		3F+(2+.l)R				--------	Loads the word of memory pointed to by .regi[] plus .ofs8[] into .reg24[].
1101110100111111........		ld (ix+ofs8),ix		3		3F+(2+.l)W				--------	Stores .regi[] into the word of memory pointed to by .regi[] plus .ofs8[].
1101110100..1111........		ld (ix+ofs8),reg24	3		3F+(2+.l)W				--------	Stores .reg24[] into the word of memory pointed to by .regi[] plus .ofs8[].

1101110101...110........		ld reg8,(ix+ofs8)	3		3F+1R					--------	Loads the byte of memory pointed to by .regi[] plus .ofs8[] into .reg8[].
1101110101110...........		ld (ix+ofs8),reg8	3		3F+1W					--------	Stores .reg8[] to the byte of memory pointed to by .regi[] plus .ofs8[].
1101110101...10.			ld reg8,reg8index	2		2F					--------	The contents of .regi8[] are loaded into .reg8[].
110111010110....			ld reg8index,reg8	2		2F					--------	The contents of .reg8[] are loaded into .regi8[].

110111011000010.			add a,reg8index		2		2F					SZ-H-VNC	Adds .regi8[] to .reg8[7;1].
1101110110000110........		add a,(ix+ofs8)		3		3F+1R					SZ-H-VNC	Adds the byte of memory pointed to by .regi[] plus .ofs8[] to .reg8[7;1].
110111011000110.			adc a,reg8index		2		2F					SZ-H-VNC	Adds .regi8[] and the carry flag to .reg8[7;1].
1101110110001110........		adc a,(ix+ofs8)		3		3F+1R					SZ-H-VNC	Adds the byte of memory pointed to by .regi[] plus .ofs8[] and the carry flag to .reg8[7;1].
110111011001010.			sub a,reg8index		2		2F					SZ-H-VNC	Subtracts .regi8[] from .reg8[7;1].
1101110110010110........		sub a,(ix+ofs8)		3		3F+1R					SZ-H-VNC	Subtracts the byte of memory pointed to by .regi[] plus .ofs8[] from .reg8[7;1].
110111011001110.			sbc a,reg8index		2		2F					SZ-H-VNC	Subtracts .regi8[] and the carry flag from .reg8[7;1].
1101110110011110........		sbc a,(ix+ofs8)		3		3F+1R					SZ-H-VNC	Subtracts the byte of memory pointed to by .regi[] plus .ofs8[] and the carry flag from .reg8[7;1].
110111011010010.			and a,reg8index		2		2F					SZ-1-P00	Bitwise AND on .reg8[7;1] with .regi8[].
1101110110100110........		and a,(ix+ofs8)		3		3F+1R					SZ-1-P00	Bitwise AND on .reg8[7;1] with the byte of memory pointed to by .regi[] plus .ofs8[].
110111011010110.			xor a,reg8index		2		2F					SZ-0-P00	Bitwise XOR on .reg8[7;1] with .regi8[].
1101110110101110........		xor a,(ix+ofs8)		3		3F+1R					SZ-0-P00	Bitwise XOR on .reg8[7;1] with the byte of memory pointed to by .regi[] plus .ofs8[].
110111011011010.			or a,reg8index		2		2F					SZ-0-P00	Bitwise OR on .reg8[7;1] with .regi8[].
1101110110110110........		or a,(ix+ofs8)		3		3F+1R					SZ-0-P00	Bitwise OR on .reg8[7;1] with the byte of memory pointed to by .regi[] plus .ofs8[].
110111011011110.			cp a,reg8index		2		2F					SZ-H-VNC	Subtracts .regi8[] from .reg8[7;1] and affects flags according to the result. .reg8[7;1] is not modified.
1101110110111110........		cp a,(ix+ofs8)		3		3F+1R					SZ-H-VNC	Subtracts the byte of memory pointed to by .regi[] plus .ofs8[] from .reg8[7;1] and affects flags according to the result. .reg8[7;1] is not modified.

1101110111100001			pop ix			2		2F+(2+.l)R				--------	The word of memory pointed to by .reg24[3;1] is stored into .regi[] and .reg24[3;1] is incremented by the word size.
1101110111101001			jp (ix)			2		4F					--------	Loads the value of .regi[] into .regpc[].
1101110111111001			ld sp,ix		2		2F					--------	Loads the value of .regi[] into .reg24[3;1].

;1101110111001011			IX BIT INSTRUCTIONS
1101110111100011			ex (sp),ix		2		2F+(2+.l)R+(2+.l)W			--------	Exchanges the word of memory pointed to by .reg24[3;1] with .regi[].

1101110111100101			push ix			2		2F+(2+.l)W				--------	.reg24[3;1] is decremented by the word size and .regi[] is stored into the word of memory pointed to by .reg24[3;1].

11011101........			trap			2		2F					--------	It's a trap!


;IY BIT INSTRUCTIONS

1111110111001011........00000110	rlc (iy+ofs8)		4		4F+1R+1W+1				SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.
1111110111001011........00001110	rrc (iy+ofs8)		4		4F+1R+1W+1				SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.
1111110111001011........00010110	rl (iy+ofs8)		4		4F+1R+1W+1				SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.
1111110111001011........00011110	rr (iy+ofs8)		4		4F+1R+1W+1				SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.
1111110111001011........00100110	sla (iy+ofs8)		4		4F+1R+1W+1				SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.
1111110111001011........00101110	sra (iy+ofs8)		4		4F+1R+1W+1				SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.
1111110111001011........00111110	srl (iy+ofs8)		4		4F+1R+1W+1				SZ-0-P0C	The byte of memory pointed to by .regi[] plus .ofs8[] is shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.

1111110111001011........01...110	bit imm3,(iy+ofs8)	4		4F+1R					?Z-1-?0-	Tests bit .imm3[] of the byte of memory pointed to by .regi[] plus .ofs8[].

1111110111001011........10...110	res imm3,(iy+ofs8)	4		4F+1R+1W+1				--------	Resets bit .imm3[] of the byte of memory pointed to by .regi[] plus .ofs8[].

1111110111001011........11...110	set imm3,(iy+ofs8)	4		4F+1R+1W+1				--------	Sets bit .imm3[] of the byte of memory pointed to by .regi[] plus .ofs8[].

1111110111001011................	trap			4		4F					--------	It's a trap!


;IY PRIMARY INSTRUCTIONS

1111110100..1001			add iy,reg24		2		2F					---H--NC	The value of .reg24[] is added to .regi[].
1111110100100001................	ld iy,imm24		5		(4+.il)F				--------	Loads .imm24[] into .regi[].
1111110100110001........		ld ix,(iy+ofs8)		3		3F+(2+.il)R				--------	Loads the word of memory pointed to by .regi[] plus .ofs8[] into .regiopp[].

1111110100100010................	ld (imm24),iy		5		(4+.il)F+(2+.l)W			--------	Stores .regi[] into the word of memory pointed to by .imm24[].
1111110100101010................	ld iy,(imm24)		5		(4+.il)F+(2+.l)R			--------	Loads the word of memory pointed to by .imm24[] into .regi[].

1111110100100011			inc iy			2		2F					--------	Adds one to .regi[].
1111110100101011			dec iy			2		2F					--------	Subtracts one from .regi[].

111111010010.100			inc reg8index		2		2F					SZ-H-VN-	Adds one to .regi8[].
1111110100110100........		inc (iy+ofs8)		3		3F+1R+1W+1				SZ-H-VN-	Adds one to the byte of memory pointed to by .regi[] plus .ofs8[].

111111010010.101			dec reg8index		2		2F					SZ-H-VN-	Subtracts one from .regi8[].
1111110100110101........		dec (iy+ofs8)		3		3F+1R+1W+1				SZ-H-VN-	Subtracts one from the byte of memory pointed to by .regi[] plus .ofs8[].

111111010010.110........		ld reg8index,imm8	3		3F					--------	Loads .imm8[] into .regi8[].
1111110100110110................	ld (iy+ofs8),imm8	4		4F+1W					--------	Stores .imm8[] to the byte of memory pointed to by .regi[] plus .ofs8[].
1111110100111110........		ld (iy+ofs8),ix		3		3F+(2+.l)W				--------	Stores .regiopp[] into the word of memory pointed to by .regi[] plus .ofs8[].

1111110100110111........		ld iy,(iy+ofs8)		3		3F+(2+.l)R				--------	Loads the word of memory pointed to by .regi[] plus .ofs8[] into .regi[].
1111110100..0111........		ld reg24,(iy+ofs8)	3		3F+(2+.l)R				--------	Loads the word of memory pointed to by .regi[] plus .ofs8[] into .reg24[].
1111110100111111........		ld (iy+ofs8),iy		3		3F+(2+.l)W				--------	Stores .regi[] into the word of memory pointed to by .regi[] plus .ofs8[].
1111110100..1111........		ld (iy+ofs8),reg24	3		3F+(2+.l)W				--------	Stores .reg24[] into the word of memory pointed to by .regi[] plus .ofs8[].

1111110101110110			trap			2		2F					--------	It's a trap!
1111110101...110........		ld reg8,(iy+ofs8)	3		3F+1R					--------	Loads the byte of memory pointed to by .regi[] plus .ofs8[] into .reg8[].
1111110101110...........		ld (iy+ofs8),reg8	3		3F+1W					--------	Stores .reg8[] to the byte of memory pointed to by .regi[] plus .ofs8[].
1111110101...10.			ld reg8,reg8index	2		2F					--------	The contents of .regi8[] are loaded into .reg8[].
111111010110....			ld reg8index,reg8	2		2F					--------	The contents of .reg8[] are loaded into .regi8[].

111111011000010.			add a,reg8index		2		2F					SZ-H-VNC	Adds .regi8[] to .reg8[7;1].
1111110110000110........		add a,(iy+ofs8)		3		3F+1R					SZ-H-VNC	Adds the byte of memory pointed to by .regi[] plus .ofs8[] to .reg8[7;1].
111111011000110.			adc a,reg8index		2		2F					SZ-H-VNC	Adds .regi8[] and the carry flag to .reg8[7;1].
1111110110001110........		adc a,(iy+ofs8)		3		3F+1R					SZ-H-VNC	Adds the byte of memory pointed to by .regi[] plus .ofs8[] and the carry flag to .reg8[7;1].
111111011001010.			sub a,reg8index		2		2F					SZ-H-VNC	Subtracts .regi8[] from .reg8[7;1].
1111110110010110........		sub a,(iy+ofs8)		3		3F+1R					SZ-H-VNC	Subtracts the byte of memory pointed to by .regi[] plus .ofs8[] from .reg8[7;1].
111111011001110.			sbc a,reg8index		2		2F					SZ-H-VNC	Subtracts .regi8[] and the carry flag from .reg8[7;1].
1111110110011110........		sbc a,(iy+ofs8)		3		3F+1R					SZ-H-VNC	Subtracts the byte of memory pointed to by .regi[] plus .ofs8[] and the carry flag from .reg8[7;1].
111111011010010.			and a,reg8index		2		2F					SZ-1-P00	Bitwise AND on .reg8[7;1] with .regi8[].
1111110110100110........		and a,(iy+ofs8)		3		3F+1R					SZ-1-P00	Bitwise AND on .reg8[7;1] with the byte of memory pointed to by .regi[] plus .ofs8[].
111111011010110.			xor a,reg8index		2		2F					SZ-0-P00	Bitwise XOR on .reg8[7;1] with .regi8[].
1111110110101110........		xor a,(iy+ofs8)		3		3F+1R					SZ-0-P00	Bitwise XOR on .reg8[7;1] with the byte of memory pointed to by .regi[] plus .ofs8[].
111111011011010.			or a,reg8index		2		2F					SZ-0-P00	Bitwise OR on .reg8[7;1] with .regi8[].
1111110110110110........		or a,(iy+ofs8)		3		3F+1R					SZ-0-P00	Bitwise OR on .reg8[7;1] with the byte of memory pointed to by .regi[] plus .ofs8[].
111111011011110.			cp a,reg8index		2		2F					SZ-H-VNC	Subtracts .regi8[] from .reg8[7;1] and affects flags according to the result. .reg8[7;1] is not modified.
1111110110111110........		cp a,(iy+ofs8)		3		3F+1R					SZ-H-VNC	Subtracts the byte of memory pointed to by .regi[] plus .ofs8[] from .reg8[7;1] and affects flags according to the result. .reg8[7;1] is not modified.

1111110111100001			pop iy			2		2F+(2+.l)R				--------	The word of memory pointed to by .reg24[3;1] is stored into .regi[] and .reg24[3;1] is incremented by the word size.
1111110111101001			jp (iy)			2		4F					--------	Loads the value of .regi[] into .regpc[].
1111110111111001			ld sp,iy		2		2F					--------	Loads the value of .regi[] into .reg24[3;1].

;1101110111001011			IY BIT INSTRUCTIONS
1111110111100011			ex (sp),iy		2		2F+(2+.l)R+(2+.l)W			--------	Exchanges the word of memory pointed to by .reg24[3;1] with .regi[].

1111110111100101			push iy			2		2F+(2+.l)W				--------	.reg24[3;1] is decremented by the word size and .regi[] is stored into the word of memory pointed to by .reg24[3;1].

11111101........			trap			2		2F					--------	It's a trap!
